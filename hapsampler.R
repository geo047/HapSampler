#' @title Haplotype sampler
#' @aliases hapsampler
#' @description Perform haplotpe analysis
#' @param data a data frame object generated by running ‘read_data’.
#' @param  trait the column name in the data file of the trait. This must be
#'          specified.
#' @param probthresh a probability value between 0 and 1. Haplotypes with
#'          haplotype probabilities less than ‘probthresh’ are discarded.
#' @details to be written
#' @return to be written 
#' @examples
#'
#'     complete.name <- system.file("extdata", "dataexample.dat", package="HapSampler")
#'     # read in phenotypic data which is in csv format
#'     dt <- read_data(path=dirname(complete.name),
#'                                  file=basename(complete.name))
#'     
#'     hapres <- hapsampler(data=dt, trait="NAVEL", id="Animal_id", breed="Breed")
#'     print(hapres)
#'     
 hapsampler <- function (data = NULL, trait = NULL, 
                         id = NULL, 
                         breed= NULL,
                         probthresh = 0.95) 
{
    ## performing checks
    if (is.null(data)) 
        stop(" The name of the output file from read_data() needs to be specified.")
    if (!is.data.frame(data)) 
        stop("data argument must be of type data.frame. Run read_data() to input data.")
    if (is.null(trait)) 
        stop(" The name of the trait in the data file must be specified. ")
    if (is.null(id)) 
        stop(" The name of the animal id in the data file must be specified. ")
    if (is.null(breed)) 
        stop(" The name of the breed in the data file must be specified. ")
    indx <- which(names(data) == trait)
    if (length(indx) == 0) 
        stop(" The name of the trait is not a column name in the data file.")
    indx <- which(names(data) == id)
    if (length(indx) == 0) 
        stop(" The name of the animal id is not a column name in the data file.")
    indx <- which(names(data) == breed)
    if (length(indx) == 0) 
        stop(" The name of the breed is not a column name in the data file.")

    if (probthresh < 0 || probthresh > 1) 
        stop(" probthresh must be a deciminal value betwen 0 and 1.")
    indx <- which(names(data) == "prob")
    if (length(indx) == 0) 
        stop(" The data object  must contain a column heading called prob.")


    ## create directory structure
    if (.Platform$OS.type == "unix") {
        dir_path <- paste(getwd(), "/", sep = "")
    } else {
        dir_path <- paste(getwd(), "\\", sep = "")
    }
    datapath <- paste(dir_path, "Data", sep = "")
    dir.create(datapath, showWarnings = TRUE, recursive = FALSE, mode = "0777")

    datapath <- paste(dir_path, "Temp", sep = "")
    dir.create(datapath, showWarnings = TRUE, recursive = FALSE, mode = "0777")


    data <- subset(data, data$prob > 0.95)
    haps <- c(data$hap1, data$hap2)
    nhap <- max(haps)
    ct <- array(NA, nhap)
    for (i in 1:nhap) ct[i] <- sum(haps == i)
    canonical.hap <- which(ct == max(ct))

    id <- as.character(data[[id]])
    breed <- as.character( data[[breed]] )

    cphen <- data[[trait]]
    h1 <- with(data, hap1)
    h2 <- with(data, hap2)
    maxhap <- max(max(h1), max(h2))
    pen.resample <- 10
    nburn <- as.integer(pen.resample/2)
    nkeep <- pen.resample - nburn
    nsamp <- as.integer(2000)
    nchains <- 3
    n <- array(NA, 3)
    m0 <- 0
    t0 <- 0
    a <- 0
    b <- 0
    nanis <- length(h1)
    min.n <- nanis/40


 

for (i in 1:nchains) {

  print(paste("Chain ",i," of ",nchains,sep=""))

  hapstore <- array(0,maxhap)
  phap1store <- array(0,nanis)
  phap2store <- array(0,nanis)
  chain <- NULL
  mustore <- array(0,3)
  sigstore <- array(0,3)
  kept <- 0

  # starting values
  samp.pen.mu <- array(NA,3)
  samp.pen.mu[1] <- min(cphen,na.rm=T)
  samp.pen.mu[3] <- max(cphen,na.rm=T)
  samp.pen.mu[2] <- mean(samp.pen.mu,na.rm=T)

  samp.pen.sd <- array(sqrt(var(cphen,na.rm=T)),3)/5


  j <- 1
  nfail <- 0
  while (j <= pen.resample) {
    
    if (j == 1) {
      hap.assign <- sample.int(2,maxhap,replace=T) # In here rather than outside
                                        # loop to guard against an invalid 
                                        # first random sample.
    }

    xxx <- .forfortran.cont(id,cphen,h1,h2,
        samp.pen.mu,samp.pen.sd,hap.assign,nsamp)

   cat(" read data ... \n")
   .Fortran("read_data_f90")

   cat(" prepare \n")
   .Fortran("prepare")

   cat(" init random seed ... \n")
   .Fortran("init_random_seed")

    cat(" runit ... \n")
   .Fortran("runit")


  }

} ## for (i in 1:nchains)




}

