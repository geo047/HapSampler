#' @useDynLib HapSampler
#' @title Haplotype sampler
#' @aliases hapsampler
#' @description Perform haplotpe analysis
#' @param data a data frame object generated by running ‘read_data’.
#' @param  trait the column name in the data file of the trait. This must be
#'          specified.
#' @param  id   the column name in the data file of the animal id. 
#' @param  breed the column name in the data file of the breed. 
#' @param  nchains  the number of parallel chains to be run.
#' @param  runlength the run length of each chain
#' @param probthresh a probability value between 0 and 1. Haplotypes with
#'          haplotype probabilities less than ‘probthresh’ are discarded.
#' 
#' @details to be written
#' @return to be written 
#' @examples
#'
#'     complete.name <- system.file("extdata", "dataexample.dat", package="HapSampler")
#'     # read in phenotypic data which is in csv format
#'     dt <- read_data(path=dirname(complete.name),
#'                                  file=basename(complete.name))
#'     
#'     hapres <- hapsampler(data=dt, trait="NAVEL", id="Animal_id", breed="Breed",
#'                          nchains=2, runlength=2)
#'     
#'     # a plot of the chains
#'    # plotLike(hapres)
#'
#'  @export
 hapsampler <- function (data = NULL, trait = NULL, 
                         id = NULL, 
                         breed= NULL,
                         nchains=3,
                         runlength=30,
                         probthresh = 0.95) 
{
    ## performing checks
    if(!is.numeric(nchains))
       stop(" nchains must be a counting number.")
    if(nchains < 1)
       stop(" nchains must be greater than 0.")
    if(!is.numeric(runlength))
       stop(" runlength must be a  counting number.")
    if(runlength < 1)
       stop(" runlength must be greater than 0.")
    if (is.null(data)) 
        stop(" The name of the output file from read_data() needs to be specified.")
    if (!is.data.frame(data)) 
        stop("data argument must be of type data.frame. Run read_data() to input data.")
    if (is.null(trait)) 
        stop(" The name of the trait in the data file must be specified. ")
    if (is.null(id)) 
        stop(" The name of the animal id in the data file must be specified. ")
    if (is.null(breed)) 
        stop(" The name of the breed in the data file must be specified. ")
    indx <- which(names(data) == trait)
    if (length(indx) == 0) 
        stop(" The name of the trait is not a column name in the data file.")
    indx <- which(names(data) == id)
    if (length(indx) == 0) 
        stop(" The name of the animal id is not a column name in the data file.")
    indx <- which(names(data) == breed)
    if (length(indx) == 0) 
        stop(" The name of the breed is not a column name in the data file.")

    if (probthresh < 0 || probthresh > 1) 
        stop(" probthresh must be a deciminal value betwen 0 and 1.")
    indx <- which(names(data) == "prob")
    if (length(indx) == 0) 
        stop(" The data object  must contain a column heading called prob.")

pen.resample <- runlength ## to be consistent with John's original naming


    ## create directory structure
    if (.Platform$OS.type == "unix") {
        dir_path <- paste(getwd(), "/", sep = "")
    } else {
        dir_path <- paste(getwd(), "\\", sep = "")
    }
    datapath <- paste(dir_path, "Data", sep = "")
    dir.create(datapath, showWarnings = TRUE, recursive = FALSE, mode = "0777")

    datapath <- paste(dir_path, "Temp", sep = "")
    dir.create(datapath, showWarnings = TRUE, recursive = FALSE, mode = "0777")


    data <- subset(data, data$prob > 0.95)
    haps <- c(data$hap1, data$hap2)
    nhap <- max(haps)
    ct <- array(NA, nhap)
    for (i in 1:nhap) ct[i] <- sum(haps == i)
    canonical.hap <- which(ct == max(ct))

    id <- as.character(data[[id]])
    breed <- as.character( data[[breed]] )

    cphen <- data[[trait]]
    h1 <- with(data, hap1)
    h2 <- with(data, hap2)
    maxhap <- max(max(h1), max(h2))
    #pen.resample <- 10
    nburn <- as.integer(pen.resample/2)
    nkeep <- pen.resample - nburn
    nsamp <- as.integer(2000)
    #nchains <- 3
    n <- array(NA, 3)
    m0 <- 0
    t0 <- 0
    a <- 0
    b <- 0
    nanis <- length(h1)
    min.n <- nanis/40


 

for (i in 1:nchains) {

  print(paste("Chain ",i," of ",nchains,sep=""))

  hapstore <- array(0,maxhap)
  phap1store <- array(0,nanis)
  phap2store <- array(0,nanis)
  chain <- NULL
  mustore <- array(0,3)
  sigstore <- array(0,3)
  kept <- 0

  # starting values
  samp.pen.mu <- array(NA,3)
  samp.pen.mu[1] <- min(cphen,na.rm=T)
  samp.pen.mu[3] <- max(cphen,na.rm=T)
  samp.pen.mu[2] <- mean(samp.pen.mu,na.rm=T)

  samp.pen.sd <- array(sqrt(var(cphen,na.rm=T)),3)/5


  j <- 1
  nfail <- 0
  while (j <= pen.resample) {
    cat(" ooooooooooooooooooooooooooooooo",j, "\n")    
    if (j == 1) {
      hap.assign <- sample.int(2,maxhap,replace=T) # In here rather than outside
                                        # loop to guard against an invalid 
                                        # first random sample.
    }

    xxx <- .forfortran.cont(id,cphen,h1,h2,
        samp.pen.mu,samp.pen.sd,hap.assign,nsamp)

   ## Running code
   .Fortran("runf90code")

   ## Read results
   samplog <- read.table("Temp/samplog.txt",header=T)
   pi_i <- samplog$pi_i[dim(samplog)[1]]
   haplog <- read.table("Temp/haplog.txt",header=T)
   anilog <- read.table("Temp/anilog.txt",header=T)
   g <- anilog$last1 + anilog$last2 - 2

   ## Sample parameters for normal distributions
   fail <- FALSE
   vmu <- vsig <- array(NA,3)

   for (zz in 1:3) {  # For each genotype class  (AA, AB, BB)
      ss <- subset(anilog,g == zz-1)
      y <- ss$pheno[!is.na(ss$pheno)]
      n[zz] <- length(y)

      if (n[zz] < min.n) { # Guard against low allele frequency spaces
        fail <- TRUE
      } else {

        # Initialise
        tau <- 1
        mtau <- a+n[zz]/2

        for (qq in 1:10) {  # Keep last of 10 samples

          v <- 1/(tau*n[zz] + t0)
          m <- v*(tau*sum(y)+t0*m0)
          mu <- rnorm(1,m,sqrt(v))

          tau <- rgamma(1,mtau,b+sum((y-mu)^2)/2)
          sigma <- 1/tau
          # print(c(mu,sigma))
        }
        vmu[zz] <- mu
        vsig[zz] <- sigma
      }  ## if else
    }  ## end for each zz

    if (!fail) {
      nfail <- 0
      samp.pen.mu <- vmu
      samp.pen.sd <- vsig
      hap.assign <- haplog$last
      chain <- rbind(chain,c(j,pi_i,samp.pen.mu,samp.pen.sd))
      print(paste("Rep ",j," of ",pen.resample,sep=""))
      j <- j + 1

      if (j > nburn) {  # Accumulate
        kept <- kept + 1
        hapstore <- hapstore + haplog$ppoll
        phap1store <- phap1store + anilog$phap1
        phap2store <- phap2store + anilog$phap2
        mustore <- mustore + samp.pen.mu
        sigstore <- sigstore + samp.pen.sd
      }
    } else {
      nfail <- nfail + 1
    }  ## if (!fail) else
    if (nfail > 10000) {break}
  }  ##  while (j <= pen.resample)

 #############

  ofn <- paste("Temp/anisols_",i,".txt",sep="")

  anisols <- data.frame(
        id = anilog$id,
        pheno = anilog$pheno,
        hap1 = anilog$hap1,
        hap2 = anilog$hap2,
        phap1 = phap1store/kept,
        phap2 = phap2store/kept)

  write.table(anisols,ofn,quote=F,row.names=F)

  #############

  ofn <- paste("Temp/mu_",i,".txt",sep="")

  musols <- data.frame(
        muAA = mustore[1]/kept,
        muAB = mustore[2]/kept,
        muBB = mustore[3]/kept,
        sdAA = sigstore[1]/kept,
        sdAB = sigstore[2]/kept,
        sdBB = sigstore[3]/kept)

  write.table(musols,ofn,quote=F,row.names=F)

  ofn <- paste("Temp/hapsols_",i,".txt",sep="")

  hapsols <- data.frame(
        haplotype = haplog$haplotype,
        P = hapstore/kept)

  write.table(hapsols,ofn,quote=F,row.names=F)

  #############

  ofn <- paste("Temp/chain_",i,".txt",sep="")

  colnames(chain) <- c("sample","loglik","AAmu","ABmu",
                                        "BBmu","AAsd","ABsd","BBsd")

  write.table(chain,ofn,quote=F,row.names=F)

  #############



} ## for (i in 1:nchains)

  res <- list(trait=trait,
               nchains=nchains,
               nburn=nburn,
               canonical.hap = canonical.hap)
  class(res) <- "HS"   ## hapsampler class

  return(res)

}  ## end hapsampler 

#' @title HS
#' @description tests if object is a HapSampler list structure
#' @param   x  object to be tested.
#' @return  A logical value is returned. 
#' @export
is.HS <- function(x)
   inherits(x, "HS")


